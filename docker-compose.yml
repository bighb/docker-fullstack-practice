services:
  # PostgreSQL 数据库服务
  postgres:
    image: postgres:15-alpine # 使用 PostgreSQL 15 Alpine 版本镜像(体积更小)
    container_name: fullstack_postgres # 容器名称
    environment: # 环境变量配置
      POSTGRES_USER: ${DB_USER} # 数据库用户名
      POSTGRES_PASSWORD: ${DB_PASSWORD} # 数据库密码
      POSTGRES_DB: ${DB_NAME} # 默认创建的数据库名
    ports:
      - "5432:5432" # 端口映射:宿主机端口:容器端口
    volumes: # 数据卷挂载
      - postgres_data:/var/lib/postgresql/data # 持久化数据库数据
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql # 挂载初始化SQL脚本
    networks:
      - app-network # 连接到自定义网络
    healthcheck: # 健康检查配置
      test: ["CMD-SHELL", "pg_isready -U postgres"] # 检查数据库是否就绪
      interval: 10s # 每10秒检查一次
      timeout: 5s # 超时时间5秒
      retries: 5 # 失败重试5次

  # Redis 缓存服务
  redis:
    image: redis:7-alpine # 使用 Redis 7 Alpine 版本镜像
    container_name: fullstack_redis # 容器名称
    ports:
      - "6379:6379" # Redis 默认端口映射
    volumes:
      - redis_data:/data # 持久化 Redis 数据
    networks:
      - app-network # 连接到自定义网络
    healthcheck: # 健康检查配置
      test: ["CMD", "redis-cli", "ping"] # 使用 ping 命令检查 Redis 是否响应
      interval: 10s # 每10秒检查一次
      timeout: 5s # 超时时间5秒
      retries: 5 # 失败重试5次

  # Node.js 后端服务
  backend:
    build: # 构建配置
      context: ./backend # 构建上下文目录
      dockerfile: Dockerfile # 使用的 Dockerfile 文件名
      target: development # 多阶段构建目标(开发阶段)
    container_name: fullstack_backend # 容器名称
    environment: # 环境变量配置
      NODE_ENV: ${NODE_ENV} # Node 运行环境
      PORT: ${PORT} # 后端服务端口
      DB_HOST: ${DB_HOST} # 数据库主机名(容器名)
      DB_PORT: ${DB_PORT} # 数据库端口
      DB_USER: ${DB_USER} # 数据库用户名
      DB_PASSWORD: ${DB_PASSWORD} # 数据库密码
      DB_NAME: ${DB_NAME} # 数据库名
      REDIS_HOST: ${REDIS_HOST} # Redis 主机名(容器名)
      REDIS_PORT: ${REDIS_PORT} # Redis 端口
    ports:
      - "5001:5001" # 后端 API 端口映射
    volumes: # 数据卷挂载
      - ./backend/src:/app/src # 挂载源代码目录,实现热更新
      - /app/node_modules # 匿名卷,避免本地 node_modules 覆盖容器内的
    depends_on: # 依赖关系配置
      postgres:
        condition: service_healthy # 等待 postgres 健康检查通过后再启动
      redis:
        condition: service_healthy # 等待 redis 健康检查通过后再启动
    networks:
      - app-network # 连接到自定义网络
    command: npm run dev # 容器启动后执行的命令(开发模式)

  # React 前端服务
  frontend:
    build: # 构建配置
      context: ./frontend # 构建上下文目录
      dockerfile: Dockerfile # 使用的 Dockerfile 文件名
      target: development # 多阶段构建目标(开发阶段)
    container_name: fullstack_frontend # 容器名称
    environment: # 环境变量配置
      - REACT_APP_API_URL=${REACT_APP_API_URL} # 后端 API 地址
    ports:
      - "3000:3000" # React 开发服务器端口映射
    volumes: # 数据卷挂载
      - ./frontend/src:/app/src # 挂载源代码目录,实现热更新
      - ./frontend/public:/app/public # 挂载静态资源目录
      - /app/node_modules # 匿名卷,避免本地 node_modules 覆盖容器内的
    depends_on:
      - backend # 依赖后端服务
    networks:
      - app-network # 连接到自定义网络
    command: npm start # 容器启动后执行的命令(启动 React 开发服务器)

  # Nginx 反向代理服务(可选)
  nginx:
    image: nginx:alpine # 使用 Nginx Alpine 版本镜像
    container_name: fullstack_nginx # 容器名称
    ports:
      - "80:80" # HTTP 默认端口映射
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro # 挂载 Nginx 配置文件(只读)
    depends_on: # 依赖关系
      - frontend # 依赖前端服务
      - backend # 依赖后端服务
    networks:
      - app-network # 连接到自定义网络

volumes: # 命名数据卷定义
  postgres_data: # PostgreSQL 数据卷
    driver: local # 使用本地存储驱动
  redis_data: # Redis 数据卷
    driver: local # 使用本地存储驱动

networks: # 自定义网络定义
  app-network: # 应用网络名称
    driver: bridge # 使用桥接网络驱动(容器间可通过服务名互相访问)
